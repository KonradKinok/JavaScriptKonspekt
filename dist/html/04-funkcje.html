<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css">
    <!-- <style type="text/css">	@import url(./styles/stylStartowy.css);	</style> -->
    <link rel="stylesheet" href="/html/01-zajeciaWprowadzajace.2ed1891a.css">
    <link rel="stylesheet" href="/index.7643dd02.css">
    <link rel="stylesheet" href="/html/04-funkcje.19969803.css">
    <title>Funkcje</title>
  </head>
  <body class="body-container">
    <header class="menu-sticky">
      <nav class="nav-container">
        <!-- Nawigacja do innych stron -->
        <ul id="main-menu" class="nav-list-container"></ul>
      </nav>
    </header>
    <main class="main-container">
      <!-- section1 -->
      <section class="text">
        <article id="article1">
          <h1>Moduł2 - Zajęcia 4 - Funkcje</h1>
          <h2>Section1 Article1: Funkcje</h2>
          <p>
            Funkcja to podprogram, niezależny fragment kodu przeznaczony do
            wielokrotnego wykonywania tego samego zestawu instrukcji dla różnych
            wartości. Funkcje pomagają w tworzeniu dużych programów, ograniczają
            powtórzenia i lepiej izolują fragmenty kodu.
          </p>
          <p>
            Funkcję można traktować jak czarną skrzynkę, która otrzymuje coś na
            wejściu (dane) i może zwrócić coś na wyjściu (wynik wykonania
            zawartego w niej kodu).
          </p>
          <div class="">
            <img class="section1-img" src="/fn-basics.bca0ecd5.png" alt="">
          </div>
        </article>
        <article id="article2">
          <h3>Section1 Article1: Deklaracja funkcji</h3>
          <pre>
            // 1. Deklaracja funkcji multiply
            function multiply() {
                // Ciało funkcji
                console.log("Log podczas wywoływania funkcji multiply");
            }

            // 2. Wywołania funkcji multiply
            multiply();// 'To jest log podczas wywoływania funkcji multiply'
            multiply();// 'To jest log podczas wywoływania funkcji multiply'
            multiply();// 'To jest log podczas wywoływania funkcji multiply'
          </pre>
          <p>
            Deklaracja funkcji (function declaration) zaczyna się od słowa
            kluczowego function, po którym następuje jej nazwa - zwyczajowo
            czasownik odpowiadający na pytanie «Co zrobić?» oraz para nawiasów
            okrągłych. Podobnie jak dla zmiennych, korzystamy z konwencji
            camelCase
          </p>
          <p>
            Ciało funkcji znajduje się w nawiasach klamrowych {} i zawiera
            instrukcje, które zostaną wykonane podczas jej wywołania. Sama
            deklaracja nie wykona instrukcji, do tego niezbędne jest, aby
            funkcja została wywoływana za pomocą jej nazwy i pary nawiasów
            okrągłych.
          </p>
        </article>
        <article id="article3">
          <h3>Section1 Article3: Parametry i argumenty</h3>
          <p>
            Przy deklaracji, w nawiasach okrągłych po nazwie funkcji znajdują
            się parametry - "zmienne", dla których wartości będziemy podawać
            podczas wywołania.
          </p>
          <pre>
            // Deklaracja parametrów x, y, z
            function multiply(x, y, z) {
                console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            }
          </pre>
          <p>
            Parametry to zmienne lokalne dostępne tylko w ciele danej funkcji.
            Kolejne parametry oddzielone są przecinkami. Możemy zadeklarować
            zero parametrów, wtedy nawias zarówno przy deklaracji jak i przy
            wywołaniu będzie pusty.
          </p>
          <p>
            Parametry będą przyjmowane przy każdym wywołaniu funkcji, ich
            wartości podczas kilku wywołań nie będą ze sobą powiązane.
          </p>
          <p>
            Podczas wywoływania funkcji w nawiasach można przekazać argumenty
            czyli wartości dla zadeklarowanych parametrów funkcji.
          </p>
          <pre>
            // 1. Deklaracja parametrów x, y, z
            function multiply(x, y, z) {
                console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            }

            // 2. Przekazywanie argumentów
            multiply(2, 3, 5);// Wynikiem mnożenia jest 30
            multiply(4, 8, 12);// Wynikiem mnożenia jest 384
            multiply(17, 6, 25);// Wynikiem mnożenia jest 2550
          </pre>
          <p>
            Kolejność przekazywania argumentów musi odpowiadać kolejności
            zadeklarowanych parametrów: wartość pierwszego argumentu zostanie
            przypisana do pierwszego parametru, drugiego argumentu do drugiego
            parametru itd. Jeśli jest więcej parametrów niż argumentów, to
            parametrom bez odpowiadającego im argumentu zostanie przypisane
            undefined.
          </p>
        </article>
        <article id="article4">
          <h3>Section1 Article4: Zwracanie wartości</h3>
          <p>
            Operator return służy do zwrócenia wartości z ciała funkcji do
            miejsca gdzie zostaje ona wywołana. Kiedy interpreter napotka
            return, natychmiast wychodzi z funkcji (kończy jej wykonywanie) i
            zwraca określoną wartość w miejscu gdzie nastąpiło wywołanie.
          </p>
          <pre>
            function multiply(x, y, z) {
                console.log("Kod przed return jest wykonywany jak zwykle");
                // Zwracamy wynik wyrażenia mnożenia
                return x * y * z;
                console.log("Ten log nigdy nie zostanie wywołany, jest po return");
            }

            // Wynik funkcji można zapisać do zmiennej
            let result = multiply(2, 3, 5);
            console.log(result);// 30

            result = multiply(4, 8, 12);
            console.log(result);// 384

            result = multiply(17, 6, 25);
            console.log(result);// 2550
          </pre>
          <p>
            Instrukcja return bez jawnie określonej wartości zwraca wartość
            specjalną undefined. Jeśli nie ma return w ciele funkcji, nadal
            zwróci ona undefined. Z tego powodu, return bez podanej wartości
            służy tylko do przerwania wykonywania funkcji bez potrzeby użycia
            instrukcji warunkowych co w niektórych przypadkach poprawia
            czytelność kodu.
          </p>
        </article>
        <article id="article5">
          <h3>Section1 Article5: Kolejność wykonywania kodu</h3>
          <p>
            Gdy interpreter napotka wywołanie funkcji (lub metody), wstrzymuje
            wykonywanie bieżącego kodu i rozpoczyna wykonywanie kodu
            znajdującego się w ciele funkcji. Po wykonaniu całego kodu funkcji,
            interpreter opuszcza ciało funkcji, wracając do miejsca w którym
            nastąpiło wywołanie i kontynuuje wykonywanie dalszego kodu.
          </p>
          <pre>
            function multiply(x, y, z) {
                console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            }

            console.log("Log przed wywołaniem funkcji multiply");
            multiply(2, 3, 5);// Wynikiem mnożenia jest 30
            console.log("Log po wywołaniu funkcji multiply");

            // Kolejność logów w konsoli
            // "Log przed wywołaniem funkcji multiply"
            // "Wynikiem mnożenia jest 30"
            // "Log po wywołaniu funkcji multiply"
          </pre>
        </article>
        <article id="article6">
          <h3>Section1 Article6: Domyślne wartości parametrów</h3>
          <p>
            Czasami konieczne jest zadeklarowanie funkcji, której parametry będą
            miały wartości inne niż undefined, nawet jeśli nie przekazano do
            nich argumentu. W nowoczesnym standardzie JavaScript wspierana jest
            bardzo prosta składnia, wystarczy podać wartość domyślną
            bezpośrednio podczas deklarowania parametrów w sygnaturze funkcji
            poprzedzając ją znakiem =. W przypadku użycia takiej konstrukcji,
            jeśli dla parametru nie zostanie przekazana wartość argumentu, użyta
            zostanie wartość podana przez nas jako domyślna.
          </p>
          <pre>
            function count(countFrom = 0, countTo = 10, step = 1) {
                console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);

                for (let i = countFrom; i <= countTo; i += step) {
                    console.log(i);
                }
            }

            count(1, 5);// countFrom = 1, countTo = 5, step = 1
            count(2);// countFrom = 2, countTo = 10, step = 1
            count();// countFrom = 0, countTo = 10, step = 1
          </pre>
        </article>
        <article id="article7">
          <h3>Section1 Article7: Pseudotablica arguments</h3>
          <p>
            Dostęp do listy wszystkich argumentów podanych przy wywołaniu można
            uzyskać za pomocą specjalnej zmiennej arguments, która jest dostępna
            tylko wewnątrz funkcji i przechowuje wszystkie argumenty jako
            pseudotablicę.
          </p>
          <p>
            Pseudotablica to kolekcja z właściwością length i możliwością
            dostępu do elementu przez indeks, natomiast nie posiada ona
            większości metod normalnie dostępnych w tablicach.
          </p>
          <p>
            Zobaczmy przykład użycia arguments w funkcji mnożącej dowolną ilość
            argumentów. Do iterowania po argumentach użyjemy pętli for...of
          </p>
          <pre>
            function multiply() {  
              let total = 1;

              for (const argument of arguments) {
                total *= argument;  
              }

              return total;
            }

            console.log(multiply(1, 2, 3));//  6
            console.log(multiply(1, 2, 3, 4));//  24
            console.log(multiply(1, 2, 3, 4, 5));//  120
          </pre>
        </article>
        <article id="article8">
          <h3>Section1 Article8: Konwersja pseudotablicy</h3>
          <p>
            Czasami pseudotablica musi zostać przekonwertowana na normalną
            tablicę, ponieważ pseudotablica nie ma metod tablicowych, takich jak
            slice() albo includes(). Zobaczmy dwa przykłady jak możemy to
            osiągnąć
          </p>
          <p>
            Użycie metody Array.from(), która zamieni tablicę na pseudotablicę.
          </p>
          <pre>
            function fn() {
              // Zmienna args będzie zawierać pełnowartościową tablicę
              const args = Array.from(arguments);
            }
          </pre>
          <p>
            Użycie operatora ... (spread) dzięki któremu wypełniamy literał
            tablicy wartościami z pseudotablicy (więcej zastosowań operatora
            spread poznamy w dalszych partiach materiału)
          </p>
          <pre>
            function fn() {
              // Zmienna args będzie zawierać pełnowartościową tablicę
              const args = [...arguments]
            }
          </pre>
          <p>
            Używając operacji ... (rest), możemy zebrać dowolną liczbę
            elementów, w naszym przypadku argumentów, do tablicy i przechowywać
            ją w zmiennej. Wszystkie argumenty zbieramy za pomocą operacji rest
            bezpośrednio w sygnaturze funkcji bez podania innych argumentów.
          </p>
          <pre>
            function fn(...args) {
              // Zmienna args będzie zawierać pełnowartościową tablicę
            }
          </pre>
          <p>
            Możemy również zadeklarować kilka "stałych" parametrów i zebrać
            pozostałe do tablicy args
          </p>
          <pre>
            function fn(a, b, ...args) {
              // zmienna a i b będą zwykłymi parametrami przechowującymi
              // odpowiednio pierwszy i drugi podany argument
              // Zmienna args będzie zawierać pełnowartościową tablicę z trzecim, czwartym
              // i kolejnymi podanymi argumentami
            }
          </pre>
          <p>
            Operację rest omówiono bardziej szczegółowo w dalszej części kursu,
            a tutaj pokazano jedno z jej możliwych zastosowań.
          </p>
        </article>
        <article id="article9">
          <h3>Section1 Article9: Wzorzec "Early Return"</h3>
          <p>
            Operator if...else jest głównym sposobem tworzenia rozgałęzień
            warunkowych. Czasami jednak złożone, zagnieżdżone warunki sprawiają,
            że kod jest trudny do zrozumienia.
          </p>
          <p>
            Stwórzmy funkcję, która opracowuje wypłaty z osobistego konta
            bankowego. Otrzymuje jako argumenty kwotę wypłaty oraz saldo
            rachunku bieżącego, po czym, w zależności od warunku, wykonuje
            odpowiedni blok instrukcji.
          </p>
          <pre>
            function withdraw(amount, balance) {
              if (amount === 0) {
                console.log("Wprowadź kwotę większą od zera");
              } else if (amount > balance) {
                console.log("Za mało środków na koncie");
              } else {
                console.log("Operacja wypłaty powiodła się");
              }
            }

            withdraw(0, 300);// "Wprowadź kwotę większą od zera"
            withdraw(500, 300);// "Za mało środków na koncie"
            withdraw(100, 300);// "Operacja wypłaty powiodła się"
          </pre>
          <p>
            Nawet w tak prostym przykładzie istnieje kilka zagnieżdżonych
            operatorów warunkowych, które musimy przeanalizować w całości, aby
            zrozumieć logikę wykonywania kodu.
          </p>
          <p>
            W jednej funkcji może być więcej niż jedna instrukcja return. Musimy
            pamiętać, że wykonywanie funkcji jest przerywane, gdy interpreter
            napotka zwrot w dowolnym miejscu, a cały kod po nim zostanie
            zignorowany w bieżącym wywołaniu funkcji.
          </p>
          <p>
            Wzorzec "Early Return" jest sposobem na wykorzystanie możliwości
            wcześniejszego wyjścia z funkcji przy użyciu operatora return.
            Korzystając z tej techniki, otrzymujemy czystszy, bardziej płaski i
            bardziej zrozumiały kod, który jest łatwiejszy do refaktoryzacji lub
            rozbudowania.
          </p>
          <p>
            Dodajmy wszystkie sprawdzenia warunków w oddzielnych instrukcjach
            if, w każdym bloku instrukcję return, a na końcu ten fragment kodu
            który wcześniej znajdował się w bloku else. W tym przypadku
            otrzymamy płaską strukturę warunków, następujących po sobie, a na
            końcu blok, który zostanie wykonany tylko wtedy, gdy nie zostanie
            wykonana żadna instrukcja warunkowa if.
          </p>
          <pre>
            function withdraw(amount, balance) {
              // Jeśli warunek jest wykonany, wywoływany jest console.log
              // i wyjście z funkcji. 
              // Kod następujący po tym bloku if nie zostanie wtedy wykonany.
              if (amount === 0) {
                console.log("Wprowadź kwotę większą od zera");
                return;
              }

              // Jeśli warunek pierwszego if nie jest wykonany, jest on pomijany
              // a interpreter przechodzi do drugiego if.
              // Jeśli warunek jest wykonany, wywoływany jest console.log i wyjście z funkcji.
              // Kod następujący po tym bloku if nie zostanie wtedy wykonany.
              if (amount > balance) {
                console.log("Za mało środków na koncie");
                return;
              }

              // Jeśli żaden z poprzednich if nie został wykonany,
              // interpreter natrafia na ten fragment kodu i wykonuje go.
              // kolejne return nie jest tu koniecznie ponieważ funkcja i tak się kończy
              console.log("Operacja wypłaty zakończona");
            }

            withdraw(0, 300);// "Wprowadź kwotę większą od zera"
            withdraw(500, 300);// "Za mało środków na koncie"
            withdraw(100, 300);// "Operacja wypłaty zakończona"
          </pre>
        </article>
        <article id="article10">
          <h3>Section1 Article10: Wyrażenie funkcyjne</h3>
          <p>
            Wyrażenie funkcyjne (function expression) to deklaracja zmiennej,
            której wartością będzie funkcja. Jest to alternatywny sposób
            deklarowania funkcji.
          </p>
          <pre>
            // Deklaracja funkcji (function declaration)
            function multiply(x, y, z) {
              console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            }

            // Wyrażenie funkcyjne (function expression)
            const multiply = function (x, y, z) {
              console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            };
          </pre>
          <p>
            Najważniejsza różnica polega na tym, że wyrażenia funkcyjnego nie
            można wywołać przed jego utworzeniem, lecz dopiero po jego
            utworzeniu, ponieważ jest to deklaracja zmiennej const. Dla
            normalnie zdefiniowanych funkcji działa mechanizm hoisting który
            sprawia, że interpreter "widzi" funkcje w miejscach w kodzie przed
            ich fizyczna deklaracją. Mechanizm ten nie działa dla zmiennych
            zadeklarowanych przy pomocy const i let
          </p>
          <pre>
            // ❌ Błąd! Wywołanie nie działa przed deklaracją
            multiply(1, 2, 3);
            const multiply = function (x, y, z) {
              console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            };
            // ✅ Wywołanie działa po deklaracji
            multiply(4, 5, 6);
          </pre>
          <p>
            Zadeklarowaną funkcję można wywołać przed miejscem jej utworzenia w
            kodzie.
          </p>
          <pre>
            // ✅ Wywołanie działa przed deklaracją
            multiply(1, 2, 3);

            function multiply(x, y, z) {
              console.log(`Wynikiem mnożenia jest ${x * y * z}`);
            }

            // ✅ Wywołanie działa po deklaracji
            multiply(4, 5, 6);
          </pre>
          <p>
            Nie ma znaczenia jakiej składni używasz, najważniejsze jest to, żeby
            kod w projekcie był przewidywalny. Oznacza to, że musisz starać się
            nie mieszać deklaracji funkcji z wyrażeniami funkcyjnymi.
          </p>
        </article>
      </section>
      <!-- section2 -->
      <section class="text">
        <article id="article1">
          <h3>Section2 Article1: Zakres</h3>
          <p>
            Zakres (scope) to mechanizm określający dostępność zmiennych w
            wykonywanym kodzie.
          </p>
          <p>
            Łańcuch zakresu (scope chain) - zakresy tworzą hierarchię, dzięki
            czemu zakresy podrzędne mogą uzyskiwać dostęp do zmiennych z
            zakresów nadrzędnych, ale nie odwrotnie.
          </p>
          <p>
            Zmienna jest widoczna dla kodu wykonywalnego tylko jeśli znajduje
            się w bieżącym scope lub scope chain
          </p>
        </article>
        <article id="article2">
          <h4>Section2 Article2: Zakres globalny</h4>
          <p>
            Zmienne zadeklarowane na najwyższym poziomie, to znaczy poza
            wszelkimi konstrukcjami, takimi jak if, while, for, oraz funkcje,
            znajdują się w zakresie globalnym i są dostępne wszędzie po ich
            zadeklarowaniu, ponieważ każdy kolejny scope jest dla nich
            podrzędny.
          </p>
          <pre>
            const globalValue = 10;
            console.log(globalValue);// 10

            function foo() {
              console.log(globalValue);// 10
            }

            for (let i = 0; i < 5; i++) {
              console.log(globalValue);// 10

              if (i === 2) {
                console.log(globalValue);// 10
              }
            }
          </pre>
        </article>
        <article id="article3">
          <h4>Section2 Article3: Zakres blokowy</h4>
          <p>
            Zmienne zadeklarowane wewnątrz instrukcji if, for, funkcji i innych
            bloków kodu ujęte w nawiasy klamrowe {}, znajdują się w zakresie
            blokowym i są dostępne tylko w tym bloku kodu lub w blokach w nim
            zagnieżdżonych.
          </p>
          <pre>
            function foo() {
              const a = 20; 
              console.log(a);// 20

              for (let i = 0; i < 5; i++) { 
                console.log(a);// 20

                if (i === 2) {
                  console.log(a);// 20
                }
              }
            }

            // ❌ Błąd! Zmienna a nie jest dostępna w zakresie globalnym
            console.log(a);

            for (let i = 0; i < 3; i++) {
              // ❌ Błąd! Zmienna a nie jest dostępna w tym zakresie
              console.log(a);
            }
          </pre>
          <p>
            Możemy porównać to do domu z pokojami. Cały dom to nasz zakres
            globalny. Każda funkcja i blok tworzy nowy pokój zagnieżdżony w
            domu. Zmienne zadeklarowane w tych pokojach są dostępne tylko wtedy,
            gdy jesteś w tym pokoju, z innego pokoju te zmienne nie są dostępne.
            Dla zakresu globalnego (domu) wszystko dostępne w dowolnych pokojach
            jest widoczne.
          </p>
          <pre>
            for (let i = 0; i < 5; i++) {
              const a = 20;  
              console.log(a);// 20

              if (i === 2) {
                const b = 30;
                console.log(a);// 20
                console.log(b);// 30  
              }

              if (i === 3) {  
                console.log(a);// 20

                // ❌ Błąd! Zmienna b nie jest dostępna w tym zakresie
                console.log(b);
              }
            }
          </pre>
        </article>
        <article id="article4">
          <h4>Section2 Article4: Wyszukiwanie za pomocą scope chain</h4>
          <p>
            Interpreter najpierw próbuje znaleźć zmienną w zakresie, w którym do
            niej się zwrócono. Jeśli nie ma takiej zmiennej w zakresie lokalnym,
            sięgamy o jeden poziom wyżej do momentu aż znajdziemy wartość albo
            zostanie osiągnięty zakres globalny. Jeżeli w żadnym momencie nie
            zostanie odnaleziona zmienna lub funkcja o danej nazwie zostanie
            wyrzucony błąd.
          </p>
        </article>
      </section>
      <!-- section3 -->
      <section class="text">
        <article id="article1">
          <h2>Section3 Article1: Stos wywołań</h2>
          <p>
            Kiedy funkcja jest wywoływana, inne funkcje mogą być wywoływane w
            jej ciele, w tych funkcjach kolejne itd. JavaScript jest językiem
            jednowątkowym, co oznacza, że tylko jedna instrukcja może być
            wykonywana na raz. Z uwagi na to, wywołane funkcje, które nie
            zakończyły swojego wykonywania, muszą zaczekać na wykonanie funkcji
            wywołanych wewnątrz siebie, aby kontynuować swoją pracę.
          </p>
          <pre>
            function fnA() {
              console.log("Log wewnątrz funkcji fnA przed wywołaniem fnB");
              fnB();
              console.log("Log wewnątrz funkcji fnA po wywołaniu fnB");
            }

            function fnB() {
              console.log("Log wewnątrz funkcji fnB");
            }

            console.log("Log przed wywołaniem fnA");
            fnA();
            console.log("Log po wywołaniu fnA");

            // "Log przed wywołaniem fnA"
            // "Log wewnątrz funkcji fnA przed wywołaniem fnB"
            // "Log wewnątrz funkcji fnB"
            // "Log wewnątrz funkcji fnA po wywołaniu fnB"
            // "Log po wywołaniu fnA"
          </pre>
          <p>
            JavaScript potrzebuje mechanizmu do przechowywania listy funkcji,
            które zostały wywołane, ale jeszcze nie zakończyły ich wykonywania
            oraz mechanizmu do zarządzania kolejnością wykonywania instrukcji w
            tych funkcjach - odpowiada za to stos wywołań. (call stack).
          </p>
        </article>
        <article id="article2">
          <h3>Section3 Article2: Stos</h3>
          <p>
            Stos to struktura danych działająca na zasadzie LIFO
            (Last-In-First-Out), czyli ostatnie weszło, pierwsze wyszło.
            Ostatnia rzecz dodana do stosu zostanie z niego usunięta jako
            pierwsza, co oznacza, że możesz dodawać lub usuwać elementy tylko ze
            szczytu stosu.
          </p>
          <p>
            Pomyśl o stosie jak o tablicy, która ma tylko metody pop i push, co
            oznacza, że możesz dodać lub usunąć tylko element na końcu kolekcji,
            a nie masz dostępu do elementów wcześniejszych. Poniżej możesz
            zobaczyć zilustrowane działanie stosu.
          </p>
          <div class="">
            <img class="section3-img" src="/stack.7a1216ae.png" alt="">
          </div>
        </article>
        <article id="article3">
          <h3>Section3 Article3: Stos wywołań</h3>
          <p>
            Stos wywołań (call stack) to mechanizm śledzenia bieżącej
            lokalizacji interpretera w kodzie w którym wywoływane jest kilka
            funkcji. Przechowuje on to
          </p>
          <ul class="unnumbered-list-container">
            <li>która z funkcji jest aktualnie wykonywana,</li>
            <li>które funkcje są wywoływane z wykonywanej funkcji,</li>
            <li>która zostanie wywołana w następnej kolejności itd.</li>
            <li>
              Kiedy skrypt wywołuje funkcję, interpreter dodaje ją do stosu
              wywołań i rozpoczyna wykonywanie.
            </li>
            <li>
              Każda funkcja wywoływana przez wykonywaną funkcję jest dodawana do
              stosu wywołań i jest wykonywana natychmiast po jej wywołaniu.
            </li>
            <li>
              Gdy wykonanie funkcji zostanie zakończone, interpreter zdejmuje ją
              ze stosu wywołań i wznawia wykonywanie kodu od punktu, w którym
              zostało ono wcześniej przerwane. Oznacza to, że rozpoczyna się
              wykonywanie funkcji, której wpis jest następny na stosie.
            </li>
          </ul>
          <p>
            Stack frame (ramka stosu) - struktura dodawana do stosu podczas
            wywołania funkcji. Przechowuje informacje takie jak nazwa funkcji i
            numer linii, w której nastąpiło wywołanie.
          </p>
          <pre>
            function bar() {
              console.log("bar");
            }

            function baz() {
              console.log("baz");
            }

            function foo() {
              console.log("foo");
              bar();
              baz();
            }

            foo();
          </pre>
          <p>
            Podczas wykonywania tego kodu najpierw wywoływane jest foo(),
            następnie wewnątrz foo() wywołuje się bar(), a następnie baz().
            Wywołania console.log() również trafiają do stosu, ponieważ jest to
            funkcja. Poniższa ilustracja przedstawia stos wywołań krok po kroku
            dla powyższego przykładu.
          </p>
          <div class="">
            <img class="section3-img-big" src="/call-stack.ace4e62d.png" alt="">
          </div>
        </article>
        <article id="article4">
          <h2>Section3 Article4: Przepełnienie stosu wywołań</h2>
          <p>
            Stos wywołań nie jest nieograniczony, ma przydzieloną skończoną
            ilość pamięci. Czasami możesz zobaczyć błąd w konsoli "Uncaught
            RangeError: Maximum call stack size exceeded" - oznacza on
            przepełnienie stosu (stack overflow).
          </p>
          <p>
            Może się to zdarzyć z powodu niewłaściwego użycia rekurencji lub
            pętli wywołań funkcji, to znaczy, jeśli istnieje nieskończona (lub
            bardzo wysoka) liczba wywołań funkcji i nie jest zwracany żaden
            wynik, czyli wywołania nigdy nie kończą się, stos rośnie. Gdy
            zostanie osiągnięty limit liczby wpisów na stosie, wystąpi taki błąd
            i skrypt zawiesi się.
          </p>
        </article>
      </section>
    </main>
    <footer class="footer">
      <div class="footer-logo">
        <img src="/konikMaly24x24Squoosh.b1d18e80.png" alt="logoImage" width="24">
        <img src="/3KLogo.3d63d982.png" alt="logoText">
      </div>
      <div id="footer-title">
        <p></p>
      </div>
      <div class="footer-date">
        <p>04.05.2024r.</p>
      </div>
    </footer>
    <!-- SKRYPTY JS -->
    <script defer="" src="/html/01-zajeciaWprowadzajace.1cba540e.js"></script>
    <script defer="" src="/html/04-funkcje.7d9576e4.js"></script>
  </body>
</html>
