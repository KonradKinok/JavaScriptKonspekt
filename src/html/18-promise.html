<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Raleway:wght@100;300;700&family=Roboto:wght@300;400&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/modern-normalize/1.0.0/modern-normalize.min.css"
    />
    <!-- <style type="text/css">	@import url(./styles/stylStartowy.css);	</style> -->
    <link rel="stylesheet" href="../styles/stylStartowy.scss" />
    <link rel="stylesheet" href="../styles/18-promise.scss" />
    <title>Promise</title>
  </head>
  <body class="body-container">
    <header class="menu-sticky">
      <nav class="nav-container">
        <!-- Nawigacja do innych stron -->
        <ul id="main-menu" class="nav-list-container"></ul>
      </nav>
    </header>
    <main class="main-container">
      <!-- section1 -->
      <section id="section1" class="text">
        <article id="article1">
          <h1>Moduł9 - Zajęcia 18 - Promise</h1>
          <h2>Obietnice</h2>
          <p>
            Polly obiecuje upiec ciasto na moje urodziny za dwa tygodnie. Jeśli
            wszystko pójdzie dobrze i ona nie zachoruje, będę miał ciasto. Jeśli
            Polly źle się poczuje, nie będzie mogła upiec ciasta. Tak czy
            inaczej impreza się odbędzie. Sama obietnica nie jest gwarancją jej
            spełnienia, nie wiemy więc z góry jaki będzie wynik działania.
            Również w programowaniu są też zadania, których wynik poznamy
            dopiero w przyszłości.
          </p>
          <div class="section1-img-container section1-grow_up-img">
            <img src="../images/main/promise-story.png" alt="" />
          </div>
          <p>
            Promise (obietnica) - obiekt reprezentujący aktualny stan operacji
            asynchronicznej. Jest to opakowanie na wartość nieznaną w momencie
            tworzenia obietnicy. Pozwala traktować wyniki operacji
            asynchronicznych tak, jakby były synchroniczne: zamiast końcowego
            wyniku operacji asynchronicznej zwracana jest obietnica otrzymania
            wyniku w przyszłości.
          </p>
          <p>Obietnica może mieć trzy stany:</p>
          <ul class="unnumbered-list-container">
            <li>
              Oczekujący (pending) - stan początkowy podczas tworzenia i
              wykonywania się obietnicy.
            </li>
            <li>
              Spełniony (fulfilled) - operacja zakończona sukcesem, z określonym
              wynikiem.
            </li>
            <li>Odrzucony (rejected) - operacja została odrzucona z błędem.</li>
          </ul>
          <div class="section1-img-container grow_up-img">
            <img src="../images/main/promise-states.png" alt="" />
          </div>
          <p>
            Kiedy obietnica jest tworzona, jest w stanie oczekującym (pending),
            po czym może zakończyć się pomyślnie (fulfilled), zwracając wynik
            (wartość) lub z błędem (rejected), zwracając przyczynę. Kiedy
            obietnica wchodzi w stan fulfilled lub rejected, jest to jej
            ostateczny stan i już się nie zmieni.
          </p>
          <p>
            Kiedy obietnica jest spełniona lub odrzucona, mówi się, że jest
            zakończona (settled). Jest to po prostu termin mówiący o tym, że
            obietnica jest w innym stanie, niż oczekujący.
          </p>
          <p>Różnice między promise a funkcją callback</p>
          <ul class="unnumbered-list-container">
            <li>callbacks to funkcje, promises to obiekty</li>
            <li>
              Wywołania zwrotne są przekazywane jako argumenty z kodu
              zewnętrznego do kodu wewnętrznego, a obietnice są zwracane z kodu
              wewnętrznego do zewnętrznego.
            </li>
            <li>
              Callbacki obsługują udane lub nieudane zakończenie operacji,
              obietnice niczego nie obsługują.
            </li>
            <li>
              Callbacki mogą obsługiwać wiele zdarzeń, obietnice są powiązane
              tylko z jednym zdarzeniem.
            </li>
          </ul>
        </article>
        <article id="article2">
          <h2>Tworzenie</h2>
          <p>
            Obietnica jest tworzona jako instancja klasy Promise, która
            przyjmuje funkcję (executor) jako argument i wywołuje ją
            natychmiast, jeszcze zanim obietnica zostanie utworzona i zwrócona.
          </p>
          <pre>
            const promise = new Promise((resolve, reject) => {
                // Asynchronous operation
            });
          </pre>
          <p>
            Funkcja executor powiadamia instancję (obietnicę), kiedy i jak
            operacja, z którą jest powiązana, zakończy się. Możemy w niej
            wykonać dowolną operację asynchroniczną, po której zakończeniu
            należy wywołać metodę resolve() - w przypadku powodzenia (stan
            fulfilled), lub reject() w przypadku błędu (stan rejected). Wartość
            zwracana (return) przez tę funkcję jest ignorowana.
          </p>
          <ul class="unnumbered-list-container">
            <li>
              resolve(value) - funkcja, którą powinniśmy wywołać po udanej
              operacji. Argumentem do niej przekazanym będzie wartość spełnionej
              obietnicy.
            </li>
            <li>
              reject(error) - funkcja do wywołania w przypadku błędu. Jej
              argumentem będzie wartość błędu dostępna w obsłudze odrzucenia
              obietnicy.
            </li>
          </ul>
          <div class="section1-img-container grow_up-img">
            <img src="../images/main/creating-promise.png" alt="" />
          </div>
          <pre>
            // Change value of isSuccess variable to call resolve or reject
            const isSuccess = true;

            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (isSuccess) {
                        resolve("Success! Value passed to resolve function");
                    } else {
                        reject("Error! Error passed to reject function");
                    }
                }, 2000);
            });
          </pre>
        </article>
        <article id="irticle3">
          <h2>Metoda then()</h2>
        </article>
      </section>
    </main>
    <footer class="container footer">
      <div class="contener-shadow-text2">
        <h2>Footer</h2>
        <div class="display-footer">
          <a
            class="link-footer"
            href=""
            target="_blank"
            rel="noreferrer noopener"
          >
            <img src="../images/footer/konikMaly24x24Squoosh.png" alt="logo" />
          </a>
          <div class="display-footer2">
            <p class="footer-selection">All rights reserved &copy;</p>
            <p>Konrad</p>
          </div>
        </div>
      </div>
    </footer>
    <!-- SKRYPTY JS -->
    <script defer src="../scripts/menu.mjs"></script>
    <script defer src="../scripts/18.mjs" type="module"></script>
  </body>
</html>
